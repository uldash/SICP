#lang racket
; #lang lazy

; при аппликативном порядке вычислений сначала полностью вычисляются операнды, а затем происходит вычисление процедуры с вычисленными значениями операндов
; Т.е. при вычислении (еуые 0 (p)) прежде всего (до собственно выполнения операций из процедуры) нужно будет вычислить (p).
; Но по хитрому определению для вычисления значения (p) необходимо вычислить значение (p).
; Таким образом интерпретатор зацикливается.
; При нормальном порядке операнды вычисляются не сразу, а лишь по мере необходимости при использовании в теле процедуры. Поэтому сначала вычисляется
; предикат if, он оказывается истинным и потому функция возвращает 0, так и не столкнувшись с необходимостью вычислить (p)
; переключится на номальный порядок выполнения #lang lazy
(define (p) (p))
(define (test x y)
  (if (= x 0)
      0
      y))

(test 0 (p))