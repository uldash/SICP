#lang lazy ; нормальный порядок, операторы вычисляются по мере необходимости
;#lang racket ; аппликативный порядок, сначала вычисляются все операторы, что в данном случае приводит к зацикливанию

;Бен Битобор придумал тест для проверки интерпретатора на то, с каким порядком вычислений он
;работает, аппликативным или нормальным. Бен определяет такие две процедуры:
;(define (p) (p))
;(define (test x y)
;(if (= x 0)
;0
;y))
;Затем он вычисляет выражение
;(test 0 (p))
;Какое поведение увидит Бен, если интерпретатор использует аппликативный порядок вычислений?
;Какое поведение он увидит, если интерпретатор использует нормальный порядок? Объясните Ваш
;ответ. (Предполагается, что правило вычисления особой формы if одинаково независимо от того,
;какой порядок вычислений используется. Сначала вычисляется выражение-предикат, и результат
;определяет, нужно ли вычислять выражение-следствие или альтернативу.)

(define (p) (p)) ; функция которая при вызове себя постоянно вызывает себя, стек растет, память утекает
(define (test x y)
  (if (= x 0)
      0
      y)
  )
(test 0 (p)) ; при аппликативном порядке, интерперетатор попытается сперва вычислить все аргументы, что
             ; не возможно, память начнет утекать, пока не будет полностью исчерпана
