#lang racket
(define (factorial-recurs n)
  (if (= n 1)
      1
      (* n (factorial-recurs (- n 1))))
  )

(factorial-recurs 6)

; factorial-iter хоть и выглядит как рекурсивный алгоритм, на самом деле это совсем не так, здесь нет возврата по стеку
; как только выполняется условие, все значения уже подсчитаны и происходит выход из процедуры
; здесь нету цепочки отложенных операций, т.е. нету того, что характеризует процесс как рекурсивный
; здесь реализован итеративный процесс
; фокус ы том, что понятия рекурсивная процедура и рекурсивный процесс описывают разные сущности
; в нашем случае factorial-iter рекурсивная процедура (т.к. ссылается на себя), описывает итерационный процесс
(define (factorial-iter n)
  (define (iter product counter)
    (if (> counter n)
        product
        (iter (* counter product) (+ counter 1))
        )
    )
  (iter 1 1)
  )

(factorial-iter 6)